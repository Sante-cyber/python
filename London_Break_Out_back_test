import MetaTrader5 as mt
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime,timedelta
import numpy as np
from common import login,password,server
import pytz
import datetime as dt

login=51658107
password='VxBvOa*4'
server='ICMarkets-Demo'

mt.initialize()
mt.login(login,password,server)

for i,x in df.iterrows():
    #open trade logic
    open_cond1=12>x['gmt_hour']>=8
    num_open_trades=trades[trades['state']=='open'].shape[0]
    open_cond2=num_open_trades==0
    # print(trades)
    if open_cond1 and open_cond2 and x['open']>x['session_high']:
        trades.loc[len(trades),trades.columns]=['open','buy',x['time_gmt'],x['open'],None,None,None]
    elif open_cond1 and open_cond2 and x['open']<x['session_low']:
        trades.loc[len(trades),trades.columns]=['open','sell',x['time_gmt'],x['open'],None,None,None]
    # print(x,open_cond1,open_cond2,trades,num_open_trades)
    if num_open_trades==0:
        continue
        
    #close trade logic
    close_cond1=x['gmt_hour']>=17
    open_trade_order_type=trades[trades['state']=='open'].iloc[0]['order_type']
    close_cond2=x['low']<=x['stoploss'] if open_trade_order_type=='buy'\
                                        else x['high']>=x['stoploss']
    # print(close_cond1,close_cond2)
    if close_cond1:
        trades.loc[trades['state']=='open',['state','close_time','close_price','close_reason']]=['closed',x['time'],x['open'],'time up']
    if close_cond2:
        trades.loc[trades['state']=='open',['state','close_time','close_price','close_reason']]=['closed',x['time'],x['stoploss'],'touch stop loss']

def find_signal(open,lower_band,upper_band):
        if open<lower_band:
            return 'sell'
        elif open>upper_band:
            return 'buy'

class position:
    def __init__(self,open_datetime,open_price,order_type,volume,sl,tp,symbol):
        self.open_datetime=open_datetime
        self.open_price=open_price
        self.order_type=order_type
        self.volume=volume
        self.sl=sl
        self.tp=tp
        self.close_datetime=None
        self.close_price=None
        self.profit=0
        self.status='open'
        self.symbol=symbol

    def close_position(self,close_date_time,close_price):
        self.close_datetime=close_date_time
        self.close_price=close_price
        self.profit=(self.close_price-self.open_price)*self.volume if self.order_type=='buy' else (self.open_price-self.close_price)*self.volume
        self.status='closed'
   
    def _asdict(self):
        return {
            'open_datetime':self.open_datetime,
            'open_price':self.open_price,
            'order_type':self.order_type,
            'volume': self.volume,
            'sl':self.sl,
            'tp':self.tp,
            'close_datetime':self.close_datetime,
            'close_price':self.close_price,
            'profit':self.profit,
            'status':self.status,
            'symbol':self.symbol
        }

class Strategy:

    def __init__(self,df,starting_balance,volume):
        self.starting_balance=starting_balance
        self.volume=volume
        self.positions=[]
        self.data=df
    
    def get_positions_df(self):
        df=pd.DataFrame([position._asdict() for position in self.positions])
        df['pnl_close']=df['profit'].cumsum()+self.starting_balance
        return df
        
    def add_position(self,position):
        self.positions.append(position)

    def trading_allowed(self):
        for pos in self.positions:
            if pos.status=='open':
                return False
        return True
    
    def run(self,trade):
        
            for i, data in self.data.iterrows():  
              if trade==True:
                  
                if data.signal=='buy' and data.gmt_hour>=8 and data.gmt_hour<12 and self.trading_allowed():
                    self.add_position(position(data.time_gmt,data.close,data.signal,self.volume,data.stoploss,None,currency))
                elif data.signal=='sell' and data.gmt_hour>=8 and data.gmt_hour<12 and self.trading_allowed():
                    self.add_position(position(data.time_gmt,data.close,data.signal,self.volume,data.stoploss,None,currency))

                for pos in self.positions:
                    if pos.status=='open':
                        # profit=(data.close-pos.open)*pos.volume if pos.order_type=='buy' else (pos.open_price-data.close)*pos.volume
                        # equity={
                        #         'open_datetime':pos.open_datetime,
                        #         'open_price':pos.open_price,
                        #         'order_type':pos.order_type,
                        #         'volume': pos.volume,
                        #         'sl':pos.sl,
                        #         'tp':pos.tp,
                        #         'close_datetime':data.time,
                        #         'close_price':data.close,
                        #         'profit':profit,
                        #         'status':pos.status,
                        #         'symbol':pos.symbol
                        #     }
                        # df1=df1.append(equity, ignore_index=True)
                        df123=self.get_positions_df()
                        # print(df123)
                        if not df123.empty:
                           profit= df123['pnl_close'].iloc[-1]
                        #    print(profit)
                        total_profit=(data.close-pos.open_price)*pos.volume+profit
                        if total_profit<profit/2 and  pos.order_type=='buy':
                            pos.close_position(data.time,data.close)
                            trade=False
                        elif total_profit<profit/2 and  pos.order_type=='sell':
                            pos.close_position(data.time,data.close)
                            trade=False
                        elif (pos.sl>=data.close and pos.order_type=='buy'):
                            pos.close_position(data.time,pos.sl)
                        elif (pos.sl<=data.close and pos.order_type=='sell'):
                            pos.close_position(data.time,pos.sl)
                        elif (pos.tp<=data.close and pos.order_type=='buy'):
                            pos.close_position(data.time,pos.tp)
                        elif (pos.tp>=data.close and pos.order_type=='sell'):
                            pos.close_position(data.time,pos.tp)
            return self.get_positions_df()

def last_sunday_of_month(year, month):
    # Get the last day of the given month
    last_day_of_month = dt.date(year, month, 1) + dt.timedelta(days=32)
    last_day_of_month = last_day_of_month.replace(day=1) - dt.timedelta(days=1)
    
    # Find the last Sunday
    while last_day_of_month.weekday() != 6:  # 6 represents Sunday
        last_day_of_month -= dt.timedelta(days=1)
    
    # Combine date with a specific time (midnight)
    last_sunday_datetime = dt.datetime.combine(last_day_of_month, dt.time.min)
    
    return last_sunday_datetime

def get_session(hour):
    if 0<=hour<8:
        return 'asian session'
    else: None


year = 2023
month=3
last_day_march=last_sunday_of_month(year, month)
month=10
last_day_oct=last_sunday_of_month(year, month)

currency='GBPJPY'
bars=mt.copy_rates_range(currency,mt.TIMEFRAME_M15,datetime(year,1,1),datetime(year,12,31))
# datetime.now()
df=pd.DataFrame(bars)
print(df)
df['time']=pd.to_datetime(df['time'],unit='s')

df['time_gmt'] = np.where( (df['time']>=last_day_march) & (df['time'] <= last_day_oct), 
                           df['time'] - pd.Timedelta(hours=3),
                           df['time'] - pd.Timedelta(hours=2))
df['gmt_hour']=df['time_gmt'].dt.hour
df['gmt_date']=df['time_gmt'].dt.date

df['session']=df['gmt_hour'].apply(get_session)

df_by_date=df.groupby(['gmt_date','session'],as_index=False).agg(
    session_high=('high','max'),
    session_low=('low','min')
)

df=df.merge(df_by_date,on=['gmt_date'],how='left')
df['stoploss']=df['session_high']-(df['session_high']-df['session_low'])/2

trades=pd.DataFrame(columns=['state','order_type','open_time','open_price','close_time','close_price','close_reason'])

for i,x in df.iterrows():
    #open trade logic
    open_cond1=12>x['gmt_hour']>=8
    num_open_trades=trades[trades['state']=='open'].shape[0]
    open_cond2=num_open_trades==0
    # print(trades)
    if open_cond1 and open_cond2 and x['open']>x['session_high']:
        trades.loc[len(trades),trades.columns]=['open','buy',x['time_gmt'],x['open'],None,None,None]
    elif open_cond1 and open_cond2 and x['open']<x['session_low']:
        trades.loc[len(trades),trades.columns]=['open','sell',x['time_gmt'],x['open'],None,None,None]
    # print(x,open_cond1,open_cond2,trades,num_open_trades)
    if num_open_trades==0:
        continue
        
    #close trade logic
    close_cond1=x['gmt_hour']>=17
    open_trade_order_type=trades[trades['state']=='open'].iloc[0]['order_type']
    close_cond2=x['low']<=x['stoploss'] if open_trade_order_type=='buy'\
                                        else x['high']>=x['stoploss']
    # print(close_cond1,close_cond2)
    if close_cond1:
        trades.loc[trades['state']=='open',['state','close_time','close_price','close_reason']]=['closed',x['time'],x['open'],'time up']
    if close_cond2:
        trades.loc[trades['state']=='open',['state','close_time','close_price','close_reason']]=['closed',x['time'],x['stoploss'],'touch stop loss']
    
trades

fig=go.Figure(
    data=[go.Candlestick(
        name='GBPJPY OHLC',
        x=df['time_gmt'],
        open=df['open'],
        high=df['high'],
        low=df['low'],
        close=df['close'],
    )]
)
fig.update_layout(xaxis_rangeslider_visible=False,height=600)
fig.add_trace(go.Scatter(name='asia_high',x=df['time_gmt'],y=df['session_high']))
fig.add_trace(go.Scatter(name='asia_low',x=df['time_gmt'],y=df['session_low']))
fig.add_trace(go.Scatter(name='stoploss',x=df['time_gmt'],y=df['stoploss']))
fig.show()

df.to_csv('E:/EA/a.csv')


# Example usage:

